"use server";

import crypto from "crypto";

import bcrypt from "bcryptjs";
import { getServerSession } from "next-auth";

import prisma from "@/app/lib/prisma";
import {
  EspecialidadeJuridica,
  InvoiceStatus,
  PaymentStatus,
  SubscriptionStatus,
  TenantStatus,
  TipoPessoa,
  UserRole,
} from "@/app/generated/prisma";
import { authOptions } from "@/auth";
import logger from "@/lib/logger";

// =============================================
// TENANT MANAGEMENT
// =============================================

export interface CreateTenantData {
  name: string;
  slug: string;
  domain?: string;
  email: string;
  telefone?: string;
  documento?: string;
  razaoSocial?: string;
  nomeFantasia?: string;
  tipoPessoa: "FISICA" | "JURIDICA";
  timezone?: string;
  adminUser: {
    firstName: string;
    lastName: string;
    email: string;
    password: string;
  };
  // Configuração Asaas (opcional)
  asaasConfig?: {
    configurarAsaas: boolean;
    asaasApiKey?: string;
    asaasAccountId?: string;
    asaasWalletId?: string;
    asaasAmbiente?: "SANDBOX" | "PRODUCAO";
  };
}

export interface TenantResponse {
  success: boolean;
  data?: any;
  error?: string;
}

const decimalToNullableNumber = (value: unknown) => {
  if (value == null) {
    return null;
  }

  if (typeof value === "number") {
    return value;
  }

  if (typeof value === "bigint") {
    return Number(value);
  }

  if (typeof value === "string") {
    const parsed = Number(value);

    return Number.isNaN(parsed) ? null : parsed;
  }

  if (
    typeof value === "object" &&
    "toString" in (value as Record<string, unknown>)
  ) {
    const parsed = Number((value as { toString(): string }).toString());

    return Number.isNaN(parsed) ? null : parsed;
  }

  return null;
};

export interface TenantManagementData {
  tenant: {
    id: string;
    name: string;
    slug: string;
    domain: string | null;
    email: string | null;
    telefone: string | null;
    documento: string | null;
    razaoSocial: string | null;
    nomeFantasia: string | null;
    timezone: string;
    status: TenantStatus;
    createdAt: string;
    updatedAt: string;
  };
  branding: {
    primaryColor: string | null;
    secondaryColor: string | null;
    accentColor: string | null;
    logoUrl: string | null;
    faviconUrl: string | null;
  } | null;
  subscription: {
    id: string | null;
    status: SubscriptionStatus | null;
    planId: string | null;
    planName: string | null;
    valorMensal: number | null;
    valorAnual: number | null;
    moeda: string | null;
    trialEndsAt: string | null;
    renovaEm: string | null;
  };
  availablePlans: Array<{
    id: string;
    nome: string;
    valorMensal: number | null;
    valorAnual: number | null;
    moeda: string;
  }>;
  metrics: {
    usuarios: number;
    processos: number;
    clientes: number;
    revenue90d: number;
    revenue30d: number;
    outstandingInvoices: number;
  };
  invoices: Array<{
    id: string;
    numero: string | null;
    status: InvoiceStatus;
    valor: number;
    vencimento: string | null;
    pagoEm: string | null;
    criadoEm: string;
  }>;
  users: Array<{
    id: string;
    name: string;
    email: string;
    role: UserRole;
    active: boolean;
    lastLoginAt: string | null;
  }>;
  availableRoles: UserRole[];
}

// Criar novo tenant
export async function createTenant(
  data: CreateTenantData,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return {
        success: false,
        error: "Acesso não autorizado para criar tenants",
      };
    }

    const superAdminId = session.user.id;

    // Verificar se slug já existe
    const existingTenant = await prisma.tenant.findUnique({
      where: { slug: data.slug },
    });

    if (existingTenant) {
      return {
        success: false,
        error: "Slug já existe. Escolha outro slug.",
      };
    }

    if (data.domain) {
      const domainConflict = await prisma.tenant.findUnique({
        where: { domain: data.domain },
      });

      if (domainConflict) {
        return {
          success: false,
          error: "Domínio já está em uso por outro tenant.",
        };
      }
    }

    // Hash da senha do admin
    const passwordHash = await bcrypt.hash(data.adminUser.password, 12);

    // Criar tenant e admin em transação
    const result = await prisma.$transaction(async (tx) => {
      // Criar tenant
      const tenant = await tx.tenant.create({
        data: {
          name: data.name,
          slug: data.slug,
          domain: data.domain,
          email: data.email,
          telefone: data.telefone,
          documento: data.documento,
          razaoSocial: data.razaoSocial,
          nomeFantasia: data.nomeFantasia,
          tipoPessoa: data.tipoPessoa,
          timezone: data.timezone || "America/Sao_Paulo",
          status: "ACTIVE",
          superAdminId, // Vinculado ao super admin
        },
      });

      // Criar usuário admin do tenant
      const adminUser = await tx.usuario.create({
        data: {
          tenantId: tenant.id,
          email: data.adminUser.email,
          passwordHash,
          firstName: data.adminUser.firstName,
          lastName: data.adminUser.lastName,
          role: "ADMIN",
          active: true,
        },
      });

      // Criar branding padrão
      await tx.tenantBranding.create({
        data: {
          tenantId: tenant.id,
          primaryColor: "#2563eb",
          secondaryColor: "#1d4ed8",
          accentColor: "#3b82f6",
        },
      });

      return { tenant, adminUser };
    });

    // Configurar Asaas se solicitado
    if (
      data.asaasConfig?.configurarAsaas &&
      data.asaasConfig.asaasApiKey &&
      data.asaasConfig.asaasAccountId
    ) {
      try {
        // Importar funções do Asaas
        const { encryptAsaasCredentials, validateAsaasApiKey } = await import(
          "@/lib/asaas"
        );

        // Validar API key
        if (!validateAsaasApiKey(data.asaasConfig.asaasApiKey)) {
          logger.warn(`API key Asaas inválida para tenant ${result.tenant.id}`);
        } else {
          // Criptografar API key
          const encryptedApiKey = encryptAsaasCredentials(
            data.asaasConfig.asaasApiKey,
          );

          // Salvar configuração Asaas
          await prisma.tenantAsaasConfig.create({
            data: {
              tenantId: result.tenant.id,
              asaasApiKey: encryptedApiKey,
              asaasAccountId: data.asaasConfig.asaasAccountId,
              asaasWalletId: data.asaasConfig.asaasWalletId || null,
              ambiente: data.asaasConfig.asaasAmbiente || "SANDBOX",
              integracaoAtiva: true,
              dataConfiguracao: new Date(),
              ultimaValidacao: new Date(),
            },
          });

          logger.info(
            `Configuração Asaas criada para tenant ${result.tenant.id}`,
          );
        }
      } catch (error) {
        logger.error(
          `Erro ao configurar Asaas para tenant ${result.tenant.id}:`,
          error,
        );
        // Não falha a criação do tenant se a configuração Asaas falhar
      }
    }

    // Log de auditoria
    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId,
        acao: "CREATE_TENANT",
        entidade: "TENANT",
        entidadeId: result.tenant.id,
        dadosNovos: {
          tenantName: result.tenant.name,
          tenantSlug: result.tenant.slug,
          adminEmail: data.adminUser.email,
        },
      },
    });

    return {
      success: true,
      data: {
        tenant: result.tenant,
        adminUser: {
          id: result.adminUser.id,
          email: result.adminUser.email,
          name: `${result.adminUser.firstName} ${result.adminUser.lastName}`,
        },
      },
    };
  } catch (error) {
    logger.error("Erro ao criar tenant:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao criar tenant",
    };
  }
}

// Listar todos os tenants
export async function getAllTenants(): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return {
        success: false,
        error: "Acesso não autorizado para listar tenants",
      };
    }

    const tenants = await prisma.tenant.findMany({
      include: {
        superAdmin: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        branding: true,
        subscription: {
          include: {
            plano: true,
          },
        },
        _count: {
          select: {
            usuarios: true,
            processos: true,
            clientes: true,
          },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    const data = tenants.map((tenant) => ({
      id: tenant.id,
      name: tenant.name,
      slug: tenant.slug,
      domain: tenant.domain,
      email: tenant.email,
      telefone: tenant.telefone,
      timezone: tenant.timezone,
      status: tenant.status,
      createdAt: tenant.createdAt.toISOString(),
      updatedAt: tenant.updatedAt.toISOString(),
      superAdmin: tenant.superAdmin
        ? {
            name: `${tenant.superAdmin.firstName} ${tenant.superAdmin.lastName}`.trim(),
            email: tenant.superAdmin.email,
          }
        : null,
      branding: tenant.branding
        ? {
            primaryColor: tenant.branding.primaryColor,
            secondaryColor: tenant.branding.secondaryColor,
            accentColor: tenant.branding.accentColor,
            logoUrl: tenant.branding.logoUrl,
            faviconUrl: tenant.branding.faviconUrl,
          }
        : null,
      plan: tenant.subscription
        ? {
            status: tenant.subscription.status,
            name: tenant.subscription.plano?.nome ?? null,
            valorMensal: decimalToNullableNumber(
              tenant.subscription.plano?.valorMensal ?? null,
            ),
            valorAnual: decimalToNullableNumber(
              tenant.subscription.plano?.valorAnual ?? null,
            ),
            moeda: tenant.subscription.plano?.moeda ?? "BRL",
            trialEndsAt: tenant.subscription.trialEndsAt?.toISOString() ?? null,
            renovaEm: tenant.subscription.renovaEm?.toISOString() ?? null,
          }
        : null,
      counts: {
        usuarios: tenant._count.usuarios,
        processos: tenant._count.processos,
        clientes: tenant._count.clientes,
      },
    }));

    return {
      success: true,
      data,
    };
  } catch (error) {
    logger.error("Erro ao buscar tenants:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao buscar tenants",
    };
  }
}

// Atualizar status do tenant
export async function updateTenantStatus(
  tenantId: string,
  status: TenantStatus,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return {
        success: false,
        error: "Acesso não autorizado para atualizar tenant",
      };
    }

    const superAdminId = session.user.id;

    const tenant = await prisma.tenant.findUnique({
      where: { id: tenantId },
    });

    if (!tenant) {
      return {
        success: false,
        error: "Tenant não encontrado",
      };
    }

    const updatedTenant = await prisma.tenant.update({
      where: { id: tenantId },
      data: { status },
    });

    // Log de auditoria
    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId,
        acao: "UPDATE_TENANT_STATUS",
        entidade: "TENANT",
        entidadeId: tenantId,
        dadosAntigos: { status: tenant.status },
        dadosNovos: { status },
      },
    });

    return {
      success: true,
      data: updatedTenant,
    };
  } catch (error) {
    logger.error("Erro ao atualizar status do tenant:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao atualizar tenant",
    };
  }
}

export interface UpdateTenantDetailsInput {
  name?: string;
  slug?: string;
  domain?: string | null;
  email?: string | null;
  telefone?: string | null;
  documento?: string | null;
  razaoSocial?: string | null;
  nomeFantasia?: string | null;
  timezone?: string;
}

export interface UpdateTenantSubscriptionInput {
  planId?: string | null;
  status?: SubscriptionStatus;
  trialEndsAt?: string | null;
  renovaEm?: string | null;
}

export interface UpdateTenantBrandingInput {
  primaryColor?: string | null;
  secondaryColor?: string | null;
  accentColor?: string | null;
  logoUrl?: string | null;
  faviconUrl?: string | null;
}

export interface UpdateTenantUserInput {
  firstName?: string;
  lastName?: string;
  email?: string;
  phone?: string;
  avatarUrl?: string;
  role?: UserRole;
  active?: boolean;
  generatePassword?: boolean;
  // Campos pessoais adicionais (todos os roles)
  cpf?: string;
  rg?: string;
  dataNascimentoUsuario?: Date | string;
  observacoes?: string;
  // Campos específicos do advogado
  oabNumero?: string;
  oabUf?: string;
  telefone?: string;
  whatsapp?: string;
  bio?: string;
  especialidades?: string[];
  comissaoPadrao?: number;
  comissaoAcaoGanha?: number;
  comissaoHonorarios?: number;
  // Campos específicos do cliente
  tipoPessoa?: string;
  documento?: string;
  telefoneCliente?: string;
  celular?: string;
  dataNascimento?: Date | string;
  inscricaoEstadual?: string;
  responsavelNome?: string;
  responsavelEmail?: string;
  responsavelTelefone?: string;
  observacoesCliente?: string;
}

export interface CreateTenantUserInput extends UpdateTenantUserInput {
  firstName: string;
  lastName: string;
  email: string;
}

export async function getTenantManagementData(
  tenantId: string,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return {
        success: false,
        error: "Acesso não autorizado",
      };
    }

    const tenant = await prisma.tenant.findUnique({
      where: { id: tenantId },
      include: {
        branding: true,
        subscription: {
          include: { plano: true },
        },
        _count: {
          select: {
            usuarios: true,
            processos: true,
            clientes: true,
          },
        },
      },
    });

    if (!tenant) {
      return {
        success: false,
        error: "Tenant não encontrado",
      };
    }

    const ninetyDaysAgo = new Date(Date.now() - 89 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(Date.now() - 29 * 24 * 60 * 60 * 1000);

    const [
      plans,
      invoices,
      users,
      revenue90Agg,
      revenue30Agg,
      outstandingInvoices,
    ] = await Promise.all([
      prisma.plano.findMany({
        where: { ativo: true },
        orderBy: { nome: "asc" },
      }),
      prisma.fatura.findMany({
        where: { tenantId },
        orderBy: { createdAt: "desc" },
        take: 8,
      }),
      prisma.usuario.findMany({
        where: { tenantId },
        orderBy: { firstName: "asc" },
        include: {
          advogado: true,
        },
      }),
      prisma.pagamento.aggregate({
        _sum: { valor: true },
        where: {
          tenantId,
          status: PaymentStatus.PAGO,
          confirmadoEm: { gte: ninetyDaysAgo },
        },
      }),
      prisma.pagamento.aggregate({
        _sum: { valor: true },
        where: {
          tenantId,
          status: PaymentStatus.PAGO,
          confirmadoEm: { gte: thirtyDaysAgo },
        },
      }),
      prisma.fatura.count({
        where: {
          tenantId,
          status: { in: [InvoiceStatus.ABERTA, InvoiceStatus.VENCIDA] },
        },
      }),
    ]);

    const data: TenantManagementData = {
      tenant: {
        id: tenant.id,
        name: tenant.name,
        slug: tenant.slug,
        domain: tenant.domain,
        email: tenant.email,
        telefone: tenant.telefone,
        documento: tenant.documento,
        razaoSocial: tenant.razaoSocial,
        nomeFantasia: tenant.nomeFantasia,
        timezone: tenant.timezone,
        status: tenant.status,
        createdAt: tenant.createdAt.toISOString(),
        updatedAt: tenant.updatedAt.toISOString(),
      },
      branding: tenant.branding
        ? {
            primaryColor: tenant.branding.primaryColor,
            secondaryColor: tenant.branding.secondaryColor,
            accentColor: tenant.branding.accentColor,
            logoUrl: tenant.branding.logoUrl,
            faviconUrl: tenant.branding.faviconUrl,
          }
        : null,
      subscription: {
        id: tenant.subscription?.id ?? null,
        status: tenant.subscription?.status ?? null,
        planId: tenant.subscription?.planoId ?? null,
        planName: tenant.subscription?.plano?.nome ?? null,
        valorMensal: decimalToNullableNumber(
          tenant.subscription?.plano?.valorMensal,
        ),
        valorAnual: decimalToNullableNumber(
          tenant.subscription?.plano?.valorAnual,
        ),
        moeda: tenant.subscription?.plano?.moeda ?? null,
        trialEndsAt: tenant.subscription?.trialEndsAt?.toISOString() ?? null,
        renovaEm: tenant.subscription?.renovaEm?.toISOString() ?? null,
      },
      availablePlans: plans.map((plan) => ({
        id: plan.id,
        nome: plan.nome,
        valorMensal: decimalToNullableNumber(plan.valorMensal),
        valorAnual: decimalToNullableNumber(plan.valorAnual),
        moeda: plan.moeda ?? "BRL",
      })),
      metrics: {
        usuarios: tenant._count.usuarios,
        processos: tenant._count.processos,
        clientes: tenant._count.clientes,
        revenue90d: decimalToNullableNumber(revenue90Agg._sum.valor) ?? 0,
        revenue30d: decimalToNullableNumber(revenue30Agg._sum.valor) ?? 0,
        outstandingInvoices,
      },
      invoices: invoices.map((invoice) => ({
        id: invoice.id,
        numero: invoice.numero,
        status: invoice.status,
        valor: decimalToNullableNumber(invoice.valor) ?? 0,
        vencimento: invoice.vencimento?.toISOString() ?? null,
        pagoEm: invoice.pagoEm?.toISOString() ?? null,
        criadoEm: invoice.createdAt.toISOString(),
      })),
      users: users.map((user) => ({
        id: user.id,
        name:
          `${user.firstName ?? ""} ${user.lastName ?? ""}`.trim() || user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phone: user.phone,
        avatarUrl: user.avatarUrl,
        role: user.role,
        active: user.active,
        lastLoginAt: user.lastLoginAt?.toISOString() ?? null,
        createdAt: user.createdAt.toISOString(),
        // Dados do advogado se existir
        oabNumero: user.advogado?.oabNumero ?? null,
        oabUf: user.advogado?.oabUf ?? null,
        telefone: user.advogado?.telefone ?? null,
        whatsapp: user.advogado?.whatsapp ?? null,
        bio: user.advogado?.bio ?? null,
        especialidades: user.advogado?.especialidades ?? null,
        comissaoPadrao: user.advogado?.comissaoPadrao
          ? parseFloat(user.advogado.comissaoPadrao.toString())
          : null,
        comissaoAcaoGanha: user.advogado?.comissaoAcaoGanha
          ? parseFloat(user.advogado.comissaoAcaoGanha.toString())
          : null,
        comissaoHonorarios: user.advogado?.comissaoHonorarios
          ? parseFloat(user.advogado.comissaoHonorarios.toString())
          : null,
      })),
      availableRoles: Object.values(UserRole),
    };

    return {
      success: true,
      data,
    };
  } catch (error) {
    logger.error("Erro ao carregar dados do tenant", error);

    return {
      success: false,
      error: "Erro interno do servidor ao carregar tenant",
    };
  }
}

export async function updateTenantDetails(
  tenantId: string,
  payload: UpdateTenantDetailsInput,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return { success: false, error: "Acesso não autorizado" };
    }

    const tenant = await prisma.tenant.findUnique({ where: { id: tenantId } });

    if (!tenant) {
      return { success: false, error: "Tenant não encontrado" };
    }

    if (payload.slug && payload.slug !== tenant.slug) {
      const slugConflict = await prisma.tenant.findUnique({
        where: { slug: payload.slug },
      });

      if (slugConflict) {
        return {
          success: false,
          error: "Slug informado já está em uso.",
        };
      }
    }

    if (payload.domain !== undefined && payload.domain !== tenant.domain) {
      if (payload.domain) {
        const domainConflict = await prisma.tenant.findUnique({
          where: { domain: payload.domain },
        });

        if (domainConflict) {
          return {
            success: false,
            error: "Domínio informado já está em uso.",
          };
        }
      }
    }

    const updateData: Record<string, unknown> = {};

    if (payload.name !== undefined) updateData.name = payload.name;
    if (payload.slug !== undefined) updateData.slug = payload.slug;
    if (payload.domain !== undefined) updateData.domain = payload.domain;
    if (payload.email !== undefined) updateData.email = payload.email;
    if (payload.telefone !== undefined) updateData.telefone = payload.telefone;
    if (payload.documento !== undefined)
      updateData.documento = payload.documento;
    if (payload.razaoSocial !== undefined)
      updateData.razaoSocial = payload.razaoSocial;
    if (payload.nomeFantasia !== undefined)
      updateData.nomeFantasia = payload.nomeFantasia;
    if (payload.timezone !== undefined) updateData.timezone = payload.timezone;

    if (Object.keys(updateData).length === 0) {
      return {
        success: true,
        data: tenant,
      };
    }

    const updatedTenant = await prisma.tenant.update({
      where: { id: tenantId },
      data: updateData,
    });

    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId: session.user.id,
        acao: "UPDATE_TENANT_DETAILS",
        entidade: "TENANT",
        entidadeId: tenantId,
        dadosAntigos: {
          name: tenant.name,
          slug: tenant.slug,
          domain: tenant.domain,
          email: tenant.email,
          telefone: tenant.telefone,
        },
        dadosNovos: {
          name: updatedTenant.name,
          slug: updatedTenant.slug,
          domain: updatedTenant.domain,
          email: updatedTenant.email,
          telefone: updatedTenant.telefone,
        },
      },
    });

    return {
      success: true,
      data: updatedTenant,
    };
  } catch (error) {
    logger.error("Erro ao atualizar dados do tenant", error);

    return {
      success: false,
      error: "Erro interno ao salvar alterações",
    };
  }
}

export async function updateTenantSubscription(
  tenantId: string,
  payload: UpdateTenantSubscriptionInput,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return { success: false, error: "Acesso não autorizado" };
    }

    const tenant = await prisma.tenant.findUnique({ where: { id: tenantId } });

    if (!tenant) {
      return { success: false, error: "Tenant não encontrado" };
    }

    let planId: string | null | undefined = payload.planId;
    let planoVersaoId: string | null | undefined = null;

    if (planId) {
      const plan = await prisma.plano.findUnique({ where: { id: planId } });

      if (!plan) {
        return {
          success: false,
          error: "Plano selecionado não existe",
        };
      }

      // Buscar a versão publicada mais recente do plano
      const versaoPublicada = await prisma.planoVersao.findFirst({
        where: {
          planoId: planId,
          status: "PUBLISHED",
        },
        orderBy: {
          numero: "desc",
        },
      });

      if (versaoPublicada) {
        planoVersaoId = versaoPublicada.id;
      }
    }

    const trialEndsAt = payload.trialEndsAt
      ? new Date(payload.trialEndsAt)
      : null;
    const renovaEm = payload.renovaEm ? new Date(payload.renovaEm) : null;

    const existingSubscription = await prisma.tenantSubscription.findUnique({
      where: { tenantId },
    });

    let subscription;

    if (existingSubscription) {
      subscription = await prisma.tenantSubscription.update({
        where: { tenantId },
        data: {
          planoId: planId ?? null,
          planoVersaoId: planoVersaoId ?? null,
          status: payload.status ?? existingSubscription.status,
          trialEndsAt,
          renovaEm,
        },
        include: {
          plano: true,
          planoVersao: true,
        },
      });
    } else {
      subscription = await prisma.tenantSubscription.create({
        data: {
          tenantId,
          planoId: planId ?? null,
          planoVersaoId: planoVersaoId ?? null,
          status: payload.status ?? SubscriptionStatus.TRIAL,
          trialEndsAt,
          renovaEm,
        },
        include: {
          plano: true,
          planoVersao: true,
        },
      });
    }

    const superAdmin = session.user.email
      ? await prisma.superAdmin.findUnique({
          where: { email: session.user.email },
          select: { id: true },
        })
      : null;

    if (!superAdmin?.id) {
      logger.warn(
        "Super admin não encontrado para auditoria ao atualizar tenant",
        { userId: session.user.id, email: session.user.email },
      );
    } else {
      await prisma.superAdminAuditLog.create({
        data: {
          superAdminId: superAdmin.id,
          acao: "UPDATE_TENANT_SUBSCRIPTION",
          entidade: "TENANT",
          entidadeId: tenantId,
          dadosNovos: {
            planId: subscription.planoId,
            status: subscription.status,
            trialEndsAt: subscription.trialEndsAt,
            renovaEm: subscription.renovaEm,
          },
        },
      });
    }

    const serialized = {
      ...subscription,
      plano: subscription.plano
        ? {
            ...subscription.plano,
            valorMensal:
              subscription.plano.valorMensal !== null &&
              subscription.plano.valorMensal !== undefined
                ? Number(subscription.plano.valorMensal)
                : null,
            valorAnual:
              subscription.plano.valorAnual !== null &&
              subscription.plano.valorAnual !== undefined
                ? Number(subscription.plano.valorAnual)
                : null,
          }
        : null,
    };

    return {
      success: true,
      data: serialized,
    };
  } catch (error) {
    logger.error("Erro ao atualizar assinatura do tenant", error);

    return {
      success: false,
      error: "Erro interno ao atualizar assinatura",
    };
  }
}

export async function updateTenantBranding(
  tenantId: string,
  payload: UpdateTenantBrandingInput,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return { success: false, error: "Acesso não autorizado" };
    }

    const tenant = await prisma.tenant.findUnique({ where: { id: tenantId } });

    if (!tenant) {
      return { success: false, error: "Tenant não encontrado" };
    }

    const branding = await prisma.tenantBranding.upsert({
      where: { tenantId },
      update: {
        primaryColor: payload.primaryColor ?? undefined,
        secondaryColor: payload.secondaryColor ?? undefined,
        accentColor: payload.accentColor ?? undefined,
        logoUrl: payload.logoUrl ?? undefined,
        faviconUrl: payload.faviconUrl ?? undefined,
      },
      create: {
        tenantId,
        primaryColor: payload.primaryColor ?? "#2563eb",
        secondaryColor: payload.secondaryColor ?? "#1d4ed8",
        accentColor: payload.accentColor ?? "#3b82f6",
        logoUrl: payload.logoUrl ?? null,
        faviconUrl: payload.faviconUrl ?? null,
      },
    });

    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId: session.user.id,
        acao: "UPDATE_TENANT_BRANDING",
        entidade: "TENANT",
        entidadeId: tenantId,
        dadosNovos: branding,
      },
    });

    return {
      success: true,
      data: branding,
    };
  } catch (error) {
    logger.error("Erro ao atualizar branding do tenant", error);

    return {
      success: false,
      error: "Erro interno ao salvar branding",
    };
  }
}

function generateTemporaryPassword(length = 12) {
  return crypto
    .randomBytes(length)
    .toString("base64")
    .replace(/[^a-zA-Z0-9]/g, "")
    .slice(0, length);
}

export async function createTenantUser(
  tenantId: string,
  payload: CreateTenantUserInput,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return { success: false, error: "Acesso não autorizado" };
    }

    // Validar email único
    const existingUser = await prisma.usuario.findFirst({
      where: {
        email: payload.email,
        tenantId: tenantId,
      },
    });

    if (existingUser) {
      return {
        success: false,
        error: "Este email já está em uso por outro usuário neste tenant",
      };
    }

    const temporaryPassword = payload.generatePassword
      ? generateTemporaryPassword()
      : undefined;
    const passwordHash = temporaryPassword
      ? await bcrypt.hash(temporaryPassword, 12)
      : null;

    // Criar usuário
    const newUser = await prisma.usuario.create({
      data: {
        tenantId: tenantId,
        email: payload.email,
        firstName: payload.firstName,
        lastName: payload.lastName,
        phone: payload.phone,
        role: payload.role || "SECRETARIA",
        active: payload.active ?? true,
        passwordHash: passwordHash,
        // Campos pessoais adicionais
        cpf: payload.cpf,
        rg: payload.rg,
        dataNascimento: payload.dataNascimentoUsuario
          ? new Date(payload.dataNascimentoUsuario)
          : undefined,
        observacoes: payload.observacoes,
      },
    });

    // Criar dados do advogado se for advogado
    if (payload.role === "ADVOGADO") {
      await prisma.advogado.create({
        data: {
          tenantId: tenantId,
          usuarioId: newUser.id,
          oabNumero: payload.oabNumero,
          oabUf: payload.oabUf,
          telefone: payload.telefone,
          whatsapp: payload.whatsapp,
          bio: payload.bio,
          especialidades: (payload.especialidades ||
            []) as EspecialidadeJuridica[],
          comissaoPadrao: payload.comissaoPadrao || 0,
          comissaoAcaoGanha: payload.comissaoAcaoGanha || 0,
          comissaoHonorarios: payload.comissaoHonorarios || 0,
        },
      });
    }

    // Criar dados do cliente se for cliente
    if (payload.role === "CLIENTE") {
      await prisma.cliente.create({
        data: {
          tenantId: tenantId,
          usuarioId: newUser.id,
          tipoPessoa: (payload.tipoPessoa || "FISICA") as TipoPessoa,
          nome:
            `${payload.firstName || ""} ${payload.lastName || ""}`.trim() ||
            payload.email,
          documento: payload.documento,
          email: payload.email,
          telefone: payload.telefoneCliente,
          celular: payload.celular,
          dataNascimento: payload.dataNascimento
            ? new Date(payload.dataNascimento)
            : undefined,
          inscricaoEstadual: payload.inscricaoEstadual,
          responsavelNome: payload.responsavelNome,
          responsavelEmail: payload.responsavelEmail,
          responsavelTelefone: payload.responsavelTelefone,
          observacoes: payload.observacoesCliente,
        },
      });
    }

    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId: session.user.id,
        acao: "CREATE_TENANT_USER",
        entidade: "USUARIO",
        entidadeId: newUser.id,
        dadosNovos: {
          email: newUser.email,
          role: newUser.role,
          generatePassword: !!temporaryPassword,
          tenantId: tenantId,
        },
      },
    });

    return {
      success: true,
      data: {
        user: newUser,
        temporaryPassword: temporaryPassword,
      },
    };
  } catch (error) {
    logger.error("Erro ao criar usuário:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao criar usuário",
    };
  }
}

export async function updateTenantUser(
  tenantId: string,
  userId: string,
  payload: UpdateTenantUserInput,
): Promise<TenantResponse> {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user ||
      session.user.role !== "SUPER_ADMIN" ||
      !session.user.id
    ) {
      return { success: false, error: "Acesso não autorizado" };
    }

    const user = await prisma.usuario.findUnique({ where: { id: userId } });

    if (!user || user.tenantId !== tenantId) {
      return {
        success: false,
        error: "Usuário não encontrado para este tenant",
      };
    }

    const updateData: Record<string, unknown> = {};
    let temporaryPassword: string | undefined;

    // Validar email único se está sendo alterado
    if (payload.email && payload.email !== user.email) {
      const existingUser = await prisma.usuario.findFirst({
        where: {
          email: payload.email,
          tenantId: tenantId,
          id: { not: userId },
        },
      });

      if (existingUser) {
        return {
          success: false,
          error: "Este email já está em uso por outro usuário neste tenant",
        };
      }

      updateData.email = payload.email;
    }

    // Atualizar firstName se fornecido
    if (
      payload.firstName !== undefined &&
      payload.firstName !== user.firstName
    ) {
      updateData.firstName = payload.firstName;
    }

    // Atualizar lastName se fornecido
    if (payload.lastName !== undefined && payload.lastName !== user.lastName) {
      updateData.lastName = payload.lastName;
    }

    // Atualizar phone se fornecido
    if (payload.phone !== undefined && payload.phone !== user.phone) {
      updateData.phone = payload.phone;
    }

    // Atualizar avatarUrl se fornecido
    if (
      payload.avatarUrl !== undefined &&
      payload.avatarUrl !== user.avatarUrl
    ) {
      updateData.avatarUrl = payload.avatarUrl;
    }

    // Atualizar campos pessoais adicionais
    if (payload.cpf !== undefined) {
      updateData.cpf = payload.cpf;
    }
    if (payload.rg !== undefined) {
      updateData.rg = payload.rg;
    }
    if (payload.dataNascimentoUsuario !== undefined) {
      updateData.dataNascimento = payload.dataNascimentoUsuario
        ? new Date(payload.dataNascimentoUsuario)
        : null;
    }
    if (payload.observacoes !== undefined) {
      updateData.observacoes = payload.observacoes;
    }

    if (payload.role && payload.role !== user.role) {
      updateData.role = payload.role;
    }

    if (payload.active !== undefined && payload.active !== user.active) {
      updateData.active = payload.active;
    }

    if (payload.generatePassword) {
      temporaryPassword = generateTemporaryPassword();
      const passwordHash = await bcrypt.hash(temporaryPassword, 12);

      updateData.passwordHash = passwordHash;
    }

    if (Object.keys(updateData).length === 0) {
      return {
        success: true,
        data: { user },
      };
    }

    // Atualizar dados do advogado se for advogado
    if (payload.role === "ADVOGADO" || user.role === "ADVOGADO") {
      const advogadoData: Record<string, unknown> = {};

      if (payload.oabNumero !== undefined) {
        advogadoData.oabNumero = payload.oabNumero;
      }
      if (payload.oabUf !== undefined) {
        advogadoData.oabUf = payload.oabUf;
      }
      if (payload.telefone !== undefined) {
        advogadoData.telefone = payload.telefone;
      }
      if (payload.whatsapp !== undefined) {
        advogadoData.whatsapp = payload.whatsapp;
      }
      if (payload.bio !== undefined) {
        advogadoData.bio = payload.bio;
      }
      if (payload.especialidades !== undefined) {
        advogadoData.especialidades =
          payload.especialidades as EspecialidadeJuridica[];
      }
      if (payload.comissaoPadrao !== undefined) {
        advogadoData.comissaoPadrao = payload.comissaoPadrao;
      }
      if (payload.comissaoAcaoGanha !== undefined) {
        advogadoData.comissaoAcaoGanha = payload.comissaoAcaoGanha;
      }
      if (payload.comissaoHonorarios !== undefined) {
        advogadoData.comissaoHonorarios = payload.comissaoHonorarios;
      }

      if (Object.keys(advogadoData).length > 0) {
        await prisma.advogado.upsert({
          where: { usuarioId: userId },
          create: {
            tenantId: tenantId,
            usuarioId: userId,
            ...advogadoData,
          },
          update: advogadoData,
        });
      }
    }

    // Atualizar dados do cliente se for cliente
    if (payload.role === "CLIENTE" || user.role === "CLIENTE") {
      const clienteData: Record<string, unknown> = {};

      if (payload.tipoPessoa !== undefined) {
        clienteData.tipoPessoa = payload.tipoPessoa;
      }
      if (payload.documento !== undefined) {
        clienteData.documento = payload.documento;
      }
      if (payload.telefoneCliente !== undefined) {
        clienteData.telefone = payload.telefoneCliente;
      }
      if (payload.celular !== undefined) {
        clienteData.celular = payload.celular;
      }
      if (payload.dataNascimento !== undefined) {
        clienteData.dataNascimento = payload.dataNascimento;
      }
      if (payload.inscricaoEstadual !== undefined) {
        clienteData.inscricaoEstadual = payload.inscricaoEstadual;
      }
      if (payload.responsavelNome !== undefined) {
        clienteData.responsavelNome = payload.responsavelNome;
      }
      if (payload.responsavelEmail !== undefined) {
        clienteData.responsavelEmail = payload.responsavelEmail;
      }
      if (payload.responsavelTelefone !== undefined) {
        clienteData.responsavelTelefone = payload.responsavelTelefone;
      }
      if (payload.observacoesCliente !== undefined) {
        clienteData.observacoes = payload.observacoesCliente;
      }

      // Atualizar nome do cliente baseado no firstName/lastName se fornecido
      if (payload.firstName !== undefined || payload.lastName !== undefined) {
        const nome =
          `${payload.firstName || user.firstName || ""} ${payload.lastName || user.lastName || ""}`.trim();

        if (nome) {
          clienteData.nome = nome;
        }
      }

      if (Object.keys(clienteData).length > 0) {
        await prisma.cliente.upsert({
          where: {
            tenantId_usuarioId: {
              tenantId: tenantId,
              usuarioId: userId,
            },
          },
          create: {
            tenantId: tenantId,
            usuarioId: userId,
            tipoPessoa: (payload.tipoPessoa || "FISICA") as TipoPessoa,
            nome:
              `${payload.firstName || ""} ${payload.lastName || ""}`.trim() ||
              payload.email ||
              "",
            email: payload.email || user.email,
            ...clienteData,
          },
          update: clienteData,
        });
      }
    }

    const updatedUser = await prisma.usuario.update({
      where: { id: userId },
      data: updateData,
    });

    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId: session.user.id,
        acao: "UPDATE_TENANT_USER",
        entidade: "USUARIO",
        entidadeId: userId,
        dadosNovos: {
          role: updatedUser.role,
          active: updatedUser.active,
          temporaryPasswordSet: Boolean(payload.generatePassword),
        },
      },
    });

    return {
      success: true,
      data: {
        user: updatedUser,
        temporaryPassword,
      },
    };
  } catch (error) {
    logger.error("Erro ao atualizar usuário do tenant", error);

    return {
      success: false,
      error: "Erro interno ao atualizar usuário",
    };
  }
}

// =============================================
// JUIZ MANAGEMENT
// =============================================

export interface CreateJuizData {
  nome: string;
  nomeCompleto?: string;
  cpf?: string;
  email?: string;
  telefone?: string;
  endereco?: string;
  cidade?: string;
  estado?: string;
  cep?: string;
  dataNascimento?: Date;
  dataPosse?: Date;
  status: "ATIVO" | "INATIVO" | "APOSENTADO";
  nivel:
    | "JUIZ_SUBSTITUTO"
    | "JUIZ_TITULAR"
    | "DESEMBARGADOR"
    | "MINISTRO"
    | "OUTROS";
  especialidades: EspecialidadeJuridica[];
  vara?: string;
  comarca?: string;
  biografia?: string;
  formacao?: string;
  experiencia?: string;
  premios?: string;
  publicacoes?: string;
  foto?: string;
  website?: string;
  linkedin?: string;
  twitter?: string;
  instagram?: string;
  observacoes?: string;
  isPublico: boolean;
  isPremium: boolean;
  precoAcesso?: number;
  tribunalId?: string;
}

// Criar novo juiz global
export async function createJuizGlobal(
  data: CreateJuizData,
  superAdminId: string,
): Promise<TenantResponse> {
  try {
    const { especialidades, tribunalId, ...rest } = data;
    const juiz = await prisma.juiz.create({
      data: {
        ...rest,
        especialidades: { set: especialidades },
        superAdminId, // Controlado pelo super admin
        tribunalId: tribunalId ?? null,
      },
    });

    // Log de auditoria
    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId,
        acao: "CREATE_JUIZ",
        entidade: "JUIZ",
        entidadeId: juiz.id,
        dadosNovos: {
          nome: juiz.nome,
          isPublico: juiz.isPublico,
          isPremium: juiz.isPremium,
        },
      },
    });

    return {
      success: true,
      data: juiz,
    };
  } catch (error) {
    logger.error("Erro ao criar juiz:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao criar juiz",
    };
  }
}

// Listar todos os juízes (globais e privados)
export async function getAllJuizes(): Promise<TenantResponse> {
  try {
    const juizes = await prisma.juiz.findMany({
      include: {
        superAdmin: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        tribunal: {
          select: {
            nome: true,
            sigla: true,
          },
        },
        _count: {
          select: {
            processos: true,
            julgamentos: true,
          },
        },
      },
      orderBy: [{ isPublico: "desc" }, { createdAt: "desc" }],
    });

    return {
      success: true,
      data: juizes,
    };
  } catch (error) {
    logger.error("Erro ao buscar juízes:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao buscar juízes",
    };
  }
}

// Atualizar juiz
export async function updateJuizGlobal(
  juizId: string,
  data: Partial<CreateJuizData>,
  superAdminId: string,
): Promise<TenantResponse> {
  try {
    // Verificar se o juiz existe e se o super admin tem permissão
    const juizExistente = await prisma.juiz.findFirst({
      where: {
        id: juizId,
        superAdminId, // Apenas o super admin que criou pode editar
      },
    });

    if (!juizExistente) {
      return {
        success: false,
        error: "Juiz não encontrado ou sem permissão para editar",
      };
    }

    const { especialidades, tribunalId, ...rest } = data;

    const juiz = await prisma.juiz.update({
      where: { id: juizId },
      data: {
        ...rest,
        ...(especialidades ? { especialidades: { set: especialidades } } : {}),
        ...(tribunalId !== undefined ? { tribunalId: tribunalId ?? null } : {}),
      },
    });

    // Log de auditoria
    await prisma.superAdminAuditLog.create({
      data: {
        superAdminId,
        acao: "UPDATE_JUIZ",
        entidade: "JUIZ",
        entidadeId: juizId,
        dadosAntigos: juizExistente,
        dadosNovos: juiz,
      },
    });

    return {
      success: true,
      data: juiz,
    };
  } catch (error) {
    logger.error("Erro ao atualizar juiz:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao atualizar juiz",
    };
  }
}

// =============================================
// AUDIT LOGS
// =============================================

// Buscar logs de auditoria
export async function getAuditLogs(
  superAdminId: string,
  limit: number = 50,
): Promise<TenantResponse> {
  try {
    const logs = await prisma.superAdminAuditLog.findMany({
      where: { superAdminId },
      orderBy: { createdAt: "desc" },
      take: limit,
    });

    return {
      success: true,
      data: logs,
    };
  } catch (error) {
    logger.error("Erro ao buscar logs de auditoria:", error);

    return {
      success: false,
      error: "Erro interno do servidor ao buscar logs",
    };
  }
}
